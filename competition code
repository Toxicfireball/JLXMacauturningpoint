#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    potentialmeter, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  quadencoder1,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  quadencoder2,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  solenoid,       sensorDigitalOut)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftfront,     tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           leftback,      tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           arm2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           cat,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           cat2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightfront,    tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           rightback,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port10,          intake2,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Note: Only this file was saved from the school's toughbook before it self-factory reset for some reason
//analog port 1 spoil
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#pragma DebuggerWindows("vexCompetitionControl")
float cmToTicks(float distance)
{
	float cm;
	//1 round=360 ticks
	//wheel circumference= 10.16cm*pi=31.09=360 ticks

	cm=distance*10.4775;
	return cm;
}
float degreetodistance (float distance)
{
	resetSensor(gyro);
	float degree;
	//1 degree=10 gyro value
	degree=distance*6.5;


	return degree;
}
//reading is in ticks-- 627.2tick/revolution
//one turn of wheels --4 inch wheels= 627.2*1ticks
//1 turn of each wheel 4*pi inches
//4*pi inches= 627.2*2 ticks

//ticks/inch=627.2*2/(4*pi)=99.82198
//for onni wheels 99.82198(encoder distance)=1 inch
//while my error is 30
//the actual error in inches - 0.3
float inchtoticks (float inch)
{
	float ticks;
	ticks=inch*26.61919474859647;
	return ticks;
}

void advFwdmk1 (int dist, int rev, int speed,)
{
	resetSensor(quadencoder1);
	resetSensor(quadencoder2);

	float error;
	float target;
	target= cmToTicks(dist);
	error= target-SensorValue[quadencoder1];



	while (error>0)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);

		error= target-SensorValue[quadencoder1];
	}
	while(error<target/6.8&&error>0)
	{
		setMotor(rightback,rev);
		setMotor(rightfront,rev);
		setMotor(leftback,rev);
		setMotor(leftfront,rev);
		error=target-SensorValue[quadencoder1];

	}

	while (error<0)
	{
		setMotor(rightback,-rev);
		setMotor(rightfront,-rev);
		setMotor(leftback,-rev);
		setMotor(leftfront,-rev);
		error= target-SensorValue[quadencoder1];
		;
	}
	if(error==0||SensorValue[quadencoder1]>=target)
	{
		setMotor(rightback,0);
		setMotor(rightfront,0);
		setMotor(leftback,0);
		setMotor(leftfront,0);

	}

}
void advTurnleft(int left,int rev,int speed)
{
	resetSensor(gyro);
	float error;
	float target;
	error= target+SensorValue[gyro];
	target= degreetodistance(left);

	while (error>0)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);


		error= target+SensorValue[gyro];
	}
	while(error<target/9&&error>0)
	{
		setMotor(rightback,rev);
		setMotor(rightfront,rev);
		setMotor(leftback,-rev);
		setMotor(leftfront,-rev);
		error= target+SensorValue[gyro];

	}
//This code seem to break the program's logic flow for all adv function if its used in conjunction with other code....
	//	while (error<0)
	//	{
	//	setMotor(rightback,-rev);
	//	setMotor(rightfront,-rev);
	//setMotor(leftback,rev);
	//	setMotor(leftfront,rev);
	//	error= target+SensorValue[gyro];
	//	}
	if(error==0||SensorValue[gyro]==error)
	{
		setMotor(rightback,0);
		setMotor(rightfront,0);
		setMotor(leftback,0);
		setMotor(leftfront,0);
	}
}
void advRev(int dist,int cor,int speed)
{
	float error;
	float target;
	error= target+SensorValue[quadencoder1];
	target= cmToTicks(dist);
	resetSensor(quadencoder1);


	while (error>0)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);

		error= target+SensorValue[quadencoder1];
	}
	while(error<target/5.5&&error>0)
	{
		setMotor(rightback,-cor);
		setMotor(rightfront,-cor);
		setMotor(leftback,-cor);
		setMotor(leftfront,-cor);
		error= target+SensorValue[quadencoder1];

	}

	while (error<0)
	{
		setMotor(rightback,cor);
		setMotor(rightfront,cor);
		setMotor(leftback,cor);
		setMotor(leftfront,cor);
		error= target+SensorValue[quadencoder1];
	}
	if(error==0||SensorValue[quadencoder1]==error)
	{
		setMotor(rightback,-cor);
		setMotor(rightfront,-cor);
		setMotor(leftback,-cor);
		setMotor(leftfront,-cor);
		sleep(700);
		stopAllMotors();

	}
}

void advturnRight(int right, int rev,int speed)
{
	resetSensor(gyro);
	int error;
	int target;
	error= target-SensorValue[gyro];
	target= degreetodistance(right);

	while (error>0)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);

		error= target-SensorValue[gyro];
	}
	while(error<target/6.8&&error>0)
	{
		setMotor(rightback,-rev);
		setMotor(rightfront,-rev);
		setMotor(leftback,rev);
		setMotor(leftfront,rev);
		error= target-SensorValue[gyro];

	}

	//	while (error<0)
	//	{
	//	setMotor(rightback,rev);
	//	setMotor(rightfront,rev);
	//	setMotor(leftback,-rev);
	//	setMotor(leftfront,-rev);
	//	error= target-SensorValue[gyro];
	//	}
	if(error==0||SensorValue[quadencoder1]==error)
	{
		stopAllMotors();

	}

}
void movebase (float speed)
{
	setMotor(rightback,speed);
	setMotor(rightfront,speed);
	setMotor(leftback,speed);
	setMotor(leftfront,speed);
}









int fixtimervalue(float rawseconds)
{
	float millisec;
	millisec=rawseconds*100;
	if(millisec<250)
	{
		millisec=250;
	}
	return millisec;
}




//kp=proportion( the fine tuning part)

void Pidbasecontrol(int target, float waittime, float maxpw, int speedlimit)
{
	resetSensor(quadencoder1);
	resetSensor(quadencoder2);
	//
	float Kp=0.2;
	float Ki=0.02;
	float Kd=0.5;
	//

	int error;
	float proportion;
	int integralraw;
	float integral;
	float lasterror;
	float derivative;
	float integralactive=inchtoticks(3);//_distance_//
	float integrallimit= speedlimit; //(this is speed limit)

	SensorValue[quadencoder1]=0;
	SensorValue[quadencoder2]=0;
	float finalpower;
	bool timerbool=true;
	clearTimer(T1);

	while(time1[T1]< fixtimervalue(waittime))
	{
		//error=target- current value
		error= inchtoticks(target)-SensorValue[quadencoder1];

		proportion=Kp*error;
		if (abs(error)< integralactive && error!=0)
		{
			integralraw=integralraw+error;
		}
		else
		{
			integralraw=0;
		}
		if(integralraw> integrallimit)
		{
			integralraw=integrallimit;
		}
		if (integralraw<- integrallimit)
		{
			integralraw=-integrallimit;
		}

		integral= Ki*integralraw; //if integralraw too big and we want to set the intlimit to the intraw do: Ki*(_value_/Ki)
		//if there is an error eg 10 you add 10 to the integralraw then keep adding the errors with the loops

		derivative= Kd*(error- lasterror);
		lasterror=error;

		if (error == 0)
		{
			derivative=0;
		}
		finalpower= proportion+integral+derivative; //proportion+derivative+integral

		if (finalpower>maxpw*127)
		{
			finalpower=maxpw*127;
		}
		else if(finalpower<-maxpw*127)
		{
			finalpower=-maxpw*127;
		}

		movebase(finalpower);
		wait1Msec(40);
		if (error<30)
		{
			timerbool=false;
		}
		if(timerbool)
		{
			clearTimer(T1);
		}
	}
	movebase(0);
}
void roller(float time,float speed)
{
	{
		clearTimer(T1);
		while(time1[T1]<time)
		{
			setMotor(intake,-speed);
			setMotor(intake2,-speed);
		}
		while(time1[T1]>=time)
		{
			setMotor(intake,0);
			setMotor(intake2,0);
			break;
		}
	}
}
void shoot( int time, int power)
{


	setMotor(cat,power);
	setMotor(cat2,-power);
	sleep(time);

	setMotor(cat,0);
	setMotor(cat2,0);

}


//Neumatics have been removed
void neumaticsflip(float time, float speed,float fwd)

{
	clearTimer(T1);
	while(time1[T1]<time)
	{
		SensorValue(solenoid)=1;
		wait(0.3);
		movebase(fwd);
	}
	while(time1[T1]>=time)
	{

		stopAllMotors();
		SensorValue(solenoid)=0;
	}


}
void turnleftmk2(float left, int speed)
{
	resetSensor(gyro);
	while(SensorValue(gyro)>-left)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);

	}
	setMotor(rightback,-9);
	setMotor(rightfront,-9);
	setMotor(leftback,9);
	setMotor(leftfront,9);
	wait(0.08);


}
void rollerflipmk3(int speed,int rollerspeed,int rollerfwd, int fwd, int rev)
{
	setMotor(intake,rollerspeed);
	setMotor(intake,rollerspeed);
	sleep(400);
	setMotor(intake,rollerspeed);
	setMotor(intake,rollerspeed);
	movebase(speed);
	sleep(rollerfwd);
	stopAllMotors();
	sleep(0.9);
	setMotor(intake,0);
	setMotor(intake,0);
	movebase(speed);
	sleep(fwd);


}
void timerfwdmk2(int time, int speed)
{
	movebase(speed);
	sleep(time);
	movebase(-10);
	sleep(20);
}
void ramball(float fwd,float speed,float push)
{
	clearTimer(T4);
	while(time1[T4]<fwd)
	{
		SensorValue[solenoid]=1;
	}
	while(time1[T4]<5)
	{
		movebase(50);
	}
	while(time1[T4]<push)
	{
		SensorValue[solenoid]=0;
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);
		setMotor(intake,90);

		roller(400,100);

	}
}
void fwd( int target, int speed)
{
	resetSensor(quadencoder1);
	while(SensorValue(quadencoder1)<target)
	{
		movebase(speed);
	}
	movebase(speed/7);
	sleep(70);
	movebase(0);
}
void grabundercap(float grab,float speed,float grab2)
{
	clearTimer(T2);
	while(time1[T2]<grab)
	{
		movebase(speed);
	}
	while(time1[T2]<grab2)
	{
		movebase(speed);
		setMotor(intake,110);
		setMotor(intake2,110);
	}
	stopAllMotors();
}
void reset(float speed,float time,float st)
{
	clearTimer(T3);
	while(time1[T3]<time)
	{
		movebase(-speed);
	}
	while(time1[T3]>=time)
	{
		movebase(st);
		break;
	}
}
void timerfwd(float speed,float time,float st)
{
	clearTimer(T3);
	while(time1[T3]<time)
	{
		movebase(speed);
	}
	while(time1[T3]>=time)
	{
		movebase(st);
	}
}
void rollerflip(float roll, float roll2,float speed,int rollspd)
{
	{
		clearTimer(T4);
		while(time1[T4]<=roll)
		{
			roller(roll,-rollspd);

		}
		while(time1[T4]<=roll2)
		{

			roller(roll2,rollspd);

			break;

		}
		stopAllMotors();
	}


}
void jam(int time, int speed)
{

	setMotor(leftfront,speed);
	setMotor(leftback,-speed);
	setMotor(rightfront,speed);
	setMotor(rightback,-speed);
	sleep(time);
	stopAllMotors();

}
void turnrightmk2(float right, int speed)
{
	resetSensor(gyro);
	while(SensorValue(gyro)<right)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);
	}
	setMotor(rightback,7);
	setMotor(rightfront,7);
	setMotor(leftback,-7);
	setMotor(leftfront,-7);
	sleep(10);

}
void resetmk2(float time,float time2, float speed)
{

	movebase(-speed);

	sleep(time2);
	movebase(-speed/6);
	sleep(100);
	movebase(0);


}
void straighten(int speed)
{

	while (SensorValue(gyro)>0)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);
	}
	while(SensorValue(gyro)<0)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);
	}

}
void encodrturnleft(int left, int speed,int slwspd)
{
	resetSensor(quadencoder1);
	while(SensorValue(quadencoder1)>-left)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);
	}
	while(SensorValue(quadencoder1)>-left/6)
		setMotor(rightback,-7);
	setMotor(rightfront,-7);
	setMotor(leftback,7);
	setMotor(leftfront,7);
	sleep(20);
}
void timerturn(int left,int speed)
{

	setMotor(rightback,speed);
	setMotor(rightfront,speed);
	setMotor(leftback,-speed);
	setMotor(leftfront,-speed);
	sleep(left);
	setMotor(rightback,0);
	setMotor(rightfront,0);
	setMotor(leftback,0);
	setMotor(leftfront,0);


}
void ramballmk2(float rollerspd, float fwdspd, int downtime,int rollertime,int uptime,int revtime)
{
	setMotor(arm,-105);
	setMotor(arm2,-105);
	sleep(downtime);
	movebase(-fwdspd+15);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(revtime);
	setMotor(arm,40);
	setMotor(arm2,40);
	movebase(fwdspd);
	setMotor(arm,0);
	setMotor(arm2,0);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(rollertime);
	movebase(-fwdspd);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(revtime);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(rollertime);
	movebase(0);
	setMotor(arm,85);
	setMotor(arm2,85);
	sleep(uptime);
	stopAllMotors();
}

void rollerflipmk2(float roll, float roll2,float speed,int rollspd)
{

	{
		clearTimer(T4);
		while(time1[T4]<=roll)
		{
			roller(roll,-rollspd);
			movebase(speed);

		}
		while(time1[T4]<=roll2)
		{

			roller(roll2,rollspd);
			movebase(speed/8);
			sleep(roll2);
			break;

		}
		stopAllMotors();
	}


}

void movearm(int time,int speed)
{
	setMotor(arm,speed);
	setMotor(arm2,speed);
	sleep(time);
	setMotor(arm,-7);
	setMotor(arm2,-7);
	sleep(20);
	setMotor(arm,0);
	setMotor(arm2,0);
}
void programmingskillmk2()
{
	//	fwd(430,30);
	//	ramballmk2(-90,40,880,500,650,600);
	//resetmk2(0,850,60);
	//	fwd(100,60);
	//	advTurnleft(96,20,60);
	//	fwd(490,40);
	//	advturnRight(88.6,40,60);
	//	resetmk2(0,700,55);
	Pidbasecontrol(60.6,0,1,100);//move fwd 12 inches with 0.25 sec delay
	// fwd(780,90);
	//	rollerflipmk2(660,210,40,90);
	roller(400,-100);
	resetmk2(0,150,80);

	advTurnleft(80,20,60);
	resetmk2(0,700,60);
	//advRev(100,5,60);
	fwd(90,60);
	//advturnRight(8,10,60);
	timerturn(63.5,-60);
	fwd(130,70);
	roller(1100,-120);
	shoot(1200,110);
	//	resetmk2(0,300,80);
	timerturn(70,60);
	wait(0.5);
	resetmk2(0,930,-80);
	wait(0.4);
	resetmk2(0,530,60);
	turnrightmk2(540,70);

	resetmk2(0,960,70);
	wait(0.2);
	fwd(480,60);
	advturnleft(85,30,60);
	resetmk2(0,990,-90);
	resetmk2(0,760,90);
	advturnRight(80,30,70);
	fwd(845,70);

	//fwd(1200,60);
	rollerflipmk2(290,400,40,-100);
	wait(0.25);
	resetmk2(0,310,60);
	wait(0,2);
	timerturn(280,60);
	wait(0.3);
	fwd(750,60);
	resetmk2(0,800,70);
	wait(0.3);

	//	advTurnright(85,30,60);
	resetmk2(0,200,60);
	wait(0.2);
	advturnRight(85,30,60);
	//	resetmk2(0,760,100);
	//	wait(0.2);
	resetmk2(0,600,80);
	wait(0.2);
	resetmk2(0,700,-60);
	wait(0.2);
	advTurnleft(85,30,60);
	wait(0.2);
	resetmk2(0,600,60);
//	resetmk2(0,200,60);
	turnrightmk2(560,60);
	resetmk2(0,600,-90);
	resetmk2(0,700,60);
	resetmk2(0,1500,100);





	//advFwdmk1(25,25,70);
	//advRev(50,20,80);
	//advturnRight(120,20,80);
	//Pidbasecontrol(31.5,0.01,1,127);
	//rollerflip(300,60,100,800);
	//advFwdmk1(15,20,80);
	//advRev(20,20,80);
	//advTurnleft(90,20,80);
	//advFwdmk1(70,20,80);
	//advRev(200,20,80);
	//advturnRight(90,20,80);
	//advFwdmk1(300,20,80);
	//Pidbasecontrol(50,0.01,1,127);
	//advturnRight(90,20,80);
	//reset(400,50,0);
	//advFwdmk1(150,5,80);
	//jam(0.06,40);

}
void programmingskillmk1()
{
	Pidbasecontrol(45,0,1,100);//move fwd 12 inches with 0.25 sec delay
	// fwd(780,90);
	rollerflip(420,00,40,90);
	roller(200,60);
	//advRev(100,5,60);
	resetmk2(0,1750,55);
	wait(0.05);
	//advFwdmk1(5,5,20);
	fwd(30,70);
	advTurnleft(80,28,80);
	resetmk2(0,1190,58);
	//turnleftmk2(646,70);
	wait(0.4);
	Pidbasecontrol(93.5,0,1,100);
	roller(200,-90);
	//turnleftmk2(20,40);
	//turnleftmk2(34,42);
	timerturn(80,60);
	roller(200,70);
	shoot(1000,120);
	fwd(100,80);
	roller(960,-127);
	shoot(1290,127);
	resetmk2(0,420,75);
	wait(0.4);
	//encodrturnleft(100,60,10);
	//turnleftmk2(30,80);
	timerturn(34,62);
	fwd(860,70);
	wait(0.7);
	timerturn(45,45);
	//	straighten(35);
	resetmk2(0,940,65);
	//turnrightmk2(580,70);
	wait(0.7);
	//	resetmk2(0,900,70);
	//	fwd(195,70);
	//	rollerflipmk3(60,-100,50,50,0);
	wait(0.4)
	//	resetmk2(0,900,70);
	wait(0.4);


	advturnRight(85,30,60);

	resetmk2(0,900,60);
	//sleep(900);
	//	ramballmk2(-90,50,800,600,550,600);
	//rollerflip(0,600,40,-90);
	//advFwdmk1(5,20,100);
	//	advRev(10,20,80);
	//advturnRight(90,20,80);
	//	Pidbasecontrol(22,0,100,127);
	//	ramball(300,100,600);
	//	advRev(5,10,60);
	//	grabundercap(200,80,600);
	//	advRev(3,10,60);
	//	advturnRight(90,20,80);
	//	ramball(300,90,800);
	//	advTurnleft(90,20,80);
	//	advFwdmk1(7,10,80);
	///	advTurnleft(90,20,80);
	//	reset(100,80,0);
}
void autonredmk1()
{
	Pidbasecontrol(40,0,1,70);
	roller(1200,-110);
	resetmk2(0,1500,60);

	fwd(100,50);
	advTurnleft(98,20,70);
	fwd(290,60);
	//timerturn(40,-50);

	shoot(1100,100);
	//	advTurnleft(10,10,70);
	fwd(150,60);
	roller(1100,-100);
	shoot(1100,100);
	//	resetmk2(0,420,70);
	//timerturn(36,50);
	resetmk2(0,150,50);
	turnleftmk2(20,36);
	//fwd(500,60);
	resetmk2(0,740,-60);
	resetmk2(0,700,60);
	turnrightmk2(580,60);
	resetmk2(0,600,70);
	fwd(150,90);
	rollerflipmk2(00,600,60,100);
	resetmk2(0,400,60);



}
void  autonredmk2()
{
	Pidbasecontrol(39,0,1,127);
	roller(700,-110);
	resetmk2(0,1400,70);
	fwd(100,60);
	advTurnleft(98,30,60);
	fwd(640,70);
	advTurnleft(95,30,60);
	resetmk2(0,1300,-60);
	movearm(870,85);
	resetmk2(0,800,60);
	wait(0.25);
	resetmk2(0,1200,120);

}
void autonbluemk1()
{
	Pidbasecontrol(35,0,1,110);
	roller(500,100);
	advRev(100,20,100);
	advFwdmk1(5,10,60);
	advTurnleft(90,20,90);
	advFwdmk1(46,20,90);
	advTurnleft(10,10,70);
	shoot(1100,100);
	advturnRight(10,10,70);
	advFwdmk1(21,20,90);
	roller(400,100);
	shoot(1100,100);
	advFwdmk1(21,20,90);
	advRev(55,20,90);
	advTurnleft(90,20,90);
	advFwdmk1(60,10,90);
	rollerflip(200,700,90,110);
	advRev(80,20,100);

}
void autobluemk2()
{
	Pidbasecontrol(34,20,1,127);
	advRev(100,20,90);
	advFwdmk1(5,20,90);
	advturnRight(90,20,80);
	Pidbasecontrol(22,0,1,127);
	advTurnleft(90,20,90);
	reset(400,90,0);
	advFwdmk1(47,10,90);
}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{

	SensorType[in8]=sensorNone;
	wait1Msec(1000);
	SensorType[in8]=sensorGyro;
	wait1Msec(1000);
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	programmingskillmk1();
	programmingskillmk2();
	//autonredmk1();

}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{

		motor[leftback]=vexRT[Ch3];
		motor[leftfront]=vexRT[Ch3];
		motor[rightback]=vexRT[Ch2];
		motor[rightfront]=vexRT[Ch2];

		motor[cat]=vexRT[Btn6U]*127;
		motor[cat2]=vexRT[Btn6U]*-127;
		motor[intake]=vexRT[Ch2Xmtr2]*1;
		motor[intake2]=vexRT[Ch2Xmtr2]*1;
		motor[arm]=vexRT[Ch3Xmtr2]*-1;
		motor[arm2]=vexRT[Ch3Xmtr2]*-1;
	}











































































































































































































}
